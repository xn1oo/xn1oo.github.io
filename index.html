<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>(name).github.io — Night Bench (Pixel Canvas)</title>
  <style>
    :root{--bg1:#040916;--bg2:#091631;--accent:#c7d2ff}
    html,body{height:100%;margin:0;background:var(--bg1);font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
    #canvas{display:block;width:100vw;height:100vh;image-rendering:pixelated}
    .ui{position:fixed;right:18px;top:18px;z-index:30;display:flex;gap:10px;align-items:center}
    .btn{width:44px;height:44px;border-radius:22px;background:rgba(255,255,255,0.06);backdrop-filter:blur(4px);display:flex;align-items:center;justify-content:center;cursor:pointer;box-shadow:0 6px 18px rgba(0,0,0,0.45)}
    .btn svg{width:22px;height:22px;filter:drop-shadow(0 1px 0 rgba(0,0,0,0.4))}
    .label{color:rgba(255,255,255,0.8);font-size:13px;margin-right:6px}
    .credits{position:fixed;left:18px;bottom:18px;color:rgba(255,255,255,0.45);font-size:13px}
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <div class="ui">
    <div class="label">Sound</div>
    <div id="mute" class="btn" title="mute / unmute (click)">
      <!-- moon icon -->
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.25" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
    </div>
  </div>

  <div class="credits">(name).github.io — static pixel night scene</div>

<script>
/* Night Bench — Pure Canvas Pixel Scene + Synth Ambient
   - Full-screen responsive canvas
   - Pixel-style layered mountains, cliffs, grass
   - Bench drawn and lit
   - Stars + moon + shooting stars every 60–120s
   - No movement: static scene with subtle animated effects (glow, twinkle)
   - Background ambient sound generated with WebAudio (crickets + wind + subtle lo-fi hum)
   - Moon-shaped toggle to mute/unmute
*/

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
let W = canvas.width = innerWidth; let H = canvas.height = innerHeight;

window.addEventListener('resize', ()=>{ W = canvas.width = innerWidth; H = canvas.height = innerHeight; initScene(); });

// Pixel scaling (we will draw higher-res but scale to crisp pixels)
const PIXEL_SCALE = 2; // larger => chunkier pixels; change if you want more pixelated look

// Scene parameters
let stars = [];
let shootingStars = [];
let mountains = [];
let bench = null;
let moon = null;

function rand(min,max){return Math.random()*(max-min)+min}
function irand(a,b){return Math.floor(rand(a,b+1))}
function clamp(v,a,b){return Math.max(a,Math.min(b,v));}

function initScene(){
  // regenerate elements when size changes
  stars = [];
  const starCount = Math.floor(250 * (W/1365));
  for(let i=0;i<starCount;i++) stars.push({x:rand(0,W), y:rand(0,H*0.55), r:rand(0.75,2.2), tw:rand(0.3,1.9), phase:rand(0,Math.PI*2)});

  mountains = [];
  const layers = 5;
  for(let i=0;i<layers;i++){
    const depth = i/(layers-1);
    const baseY = H*0.42 + depth*H*0.22;
    const color = lerpColor('#0b1630', '#2b3650', depth);
    let points = [];
    const segs = Math.round(14 + depth*18);
    for(let x=0;x<=segs;x++){
      const px = x/segs*W;
      const py = baseY + Math.sin(x*0.9 + i)* (20 + depth*40) + rand(-18,18);
      points.push({x:px,y:py});
    }
    mountains.push({points, color, depth});
  }

  // bench placement (fixed near front)
  bench = {w:Math.round(260 * Math.min(1, W/1365)), h:60, x: Math.round(W*0.5 - (260*(Math.min(1,W/1365)))/2), y: Math.round(H*0.72)};

  // moon
  moon = {x: Math.round(W*0.78), y: Math.round(H*0.2), r: Math.round(Math.min(92, H*0.12)), phase: 0.12};

  shootingStars = [];
}

function lerp(a,b,t){return a + (b-a)*t}
function hexToRgb(hex){const n=parseInt(hex.slice(1),16); return {r:(n>>16)&255,g:(n>>8)&255,b:n&255};}
function lerpColor(a,b,t){const A=hexToRgb(a),B=hexToRgb(b);return 'rgb('+Math.round(lerp(A.r,B.r,t))+','+Math.round(lerp(A.g,B.g,t))+','+Math.round(lerp(A.b,B.b,t))+')';}

initScene();

// schedule shooting stars
function scheduleNext(){
  const ms = irand(60_000,120_000);
  setTimeout(()=>{spawnShootingStar(); scheduleNext();}, ms);
}
scheduleNext();

function spawnShootingStar(){
  const sx = rand(0, W*0.6);
  const sy = rand(0, H*0.45);
  const angle = rand(-Math.PI*0.2, Math.PI*0.2) + Math.PI/8; // diagonal down-right
  const speed = rand(9, 16);
  shootingStars.push({x:sx,y:sy,vx:Math.cos(angle)*speed, vy:Math.sin(angle)*speed, life:0, maxLife:120});
}

// Audio: WebAudio ambient synth
let audioCtx = null; let masterGain = null; let isMuted = false;
function setupAudio(){
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  masterGain = audioCtx.createGain(); masterGain.gain.value = 0; masterGain.connect(audioCtx.destination);

  // gentle lo-fi hum (detuned saws)
  const hum = audioCtx.createOscillator(); hum.type='sine'; hum.frequency.value = 60; // low
  const humGain = audioCtx.createGain(); humGain.gain.value = 0.02;
  hum.connect(humGain);

  // slow pulse using LFO
  const lfo = audioCtx.createOscillator(); lfo.type='sine'; lfo.frequency.value = 0.07; // slow
  const lfoGain = audioCtx.createGain(); lfoGain.gain.value = 0.018;
  lfo.connect(lfoGain);
  lfoGain.connect(humGain.gain);

  humGain.connect(masterGain);
  hum.start(); lfo.start();

  // filtered noise for wind
  const bufferSize = 2*audioCtx.sampleRate; const noiseBuffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
  const output = noiseBuffer.getChannelData(0);
  for(let i=0;i<bufferSize;i++) output[i] = (Math.random()*2-1)*0.25;
  const noiseSource = audioCtx.createBufferSource(); noiseSource.buffer = noiseBuffer; noiseSource.loop = true;
  const noiseFilter = audioCtx.createBiquadFilter(); noiseFilter.type = 'lowpass'; noiseFilter.frequency.value = 1200;
  const noiseGain = audioCtx.createGain(); noiseGain.gain.value = 0.06;
  noiseSource.connect(noiseFilter); noiseFilter.connect(noiseGain); noiseGain.connect(masterGain);
  noiseSource.start();

  // cricket clicks (sampled via tiny synthesis)
  const cricketGain = audioCtx.createGain(); cricketGain.gain.value = 0.0; cricketGain.connect(masterGain);
  function tick(){
    const tOsc = audioCtx.createOscillator(); tOsc.type='square'; tOsc.frequency.value = rand(3800,5200);
    const tGain = audioCtx.createGain(); tGain.gain.value = 0.0001;
    tOsc.connect(tGain); tGain.connect(cricketGain);
    tOsc.start();
    // schedule clicks
    tGain.gain.linearRampToValueAtTime(0.035, audioCtx.currentTime + 0.002);
    tGain.gain.exponentialRampToValueAtTime(0.00001, audioCtx.currentTime + 0.07);
    tOsc.stop(audioCtx.currentTime + 0.08);
  }
  // periodic variable cricket rhythm
  setInterval(()=>{ if(!isMuted) {
    const cluster = irand(1,3);
    for(let i=0;i<cluster;i++) setTimeout(tick, i*irand(120,420));
  }}, irand(3000,6000));

  // fade in
  masterGain.gain.cancelScheduledValues(audioCtx.currentTime);
  masterGain.gain.setValueAtTime(0, audioCtx.currentTime);
  masterGain.gain.linearRampToValueAtTime(0.7, audioCtx.currentTime + 6);
}

// Mute toggle
const muteBtn = document.getElementById('mute');
muteBtn.addEventListener('click', ()=>{
  if(!audioCtx){ setupAudio(); audioCtx.resume(); }
  isMuted = !isMuted;
  if(isMuted) masterGain.gain.linearRampToValueAtTime(0.0001, audioCtx.currentTime + 0.5);
  else masterGain.gain.linearRampToValueAtTime(0.7, audioCtx.currentTime + 0.8);
  // visual feedback
  muteBtn.style.opacity = isMuted ? 0.6 : 1;
});

// draw loop
let start = performance.now();
function draw(now){
  const t = (now - start)/1000;
  ctx.clearRect(0,0,W,H);

  // sky gradient
  const skyGrad = ctx.createLinearGradient(0,0,0,H*0.6);
  skyGrad.addColorStop(0,'#02071a'); skyGrad.addColorStop(0.45,'#071633'); skyGrad.addColorStop(1,'#0a1730');
  ctx.fillStyle = skyGrad; ctx.fillRect(0,0,W,H);

  // distant glow near horizon
  const glow = ctx.createRadialGradient(W*0.2,H*0.6,10,W*0.2,H*0.6, H*0.6);
  glow.addColorStop(0,'rgba(120,120,160,0.02)'); glow.addColorStop(1,'rgba(10,10,20,0.0)');
  ctx.fillStyle = glow; ctx.fillRect(0,0,W,H);

  // stars
  for(const s of stars){
    const alpha = 0.5 + 0.5*Math.sin(t*s.tw + s.phase);
    ctx.globalAlpha = alpha;
    const size = Math.max(1, Math.round(s.r * (1 + 0.15*Math.sin(t*1.3 + s.phase))));
    ctx.fillStyle = 'white'; ctx.fillRect(Math.round(s.x), Math.round(s.y), size, size);
  }
  ctx.globalAlpha = 1;

  // moon with glow and subtle crater texture
  drawMoon(moon.x, moon.y, moon.r, t);

  // mountains (back to front)
  for(const m of mountains){ drawMountain(m, t); }

  // foreground cliff and grass (shorter Y-axis per request)
  drawForegroundCliff(t);

  // bench
  drawBench(bench.x, bench.y, bench.w, bench.h, t);

  // shooting stars
  for(let i=shootingStars.length-1;i>=0;i--){ const s = shootingStars[i]; s.x += s.vx; s.y += s.vy; s.life++; const a = 1 - s.life/s.maxLife; ctx.globalAlpha = a; ctx.strokeStyle = 'rgba(255,255,255,'+a+')'; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(s.x - s.vx*6, s.y - s.vy*6); ctx.lineTo(s.x, s.y); ctx.stroke(); ctx.beginPath(); ctx.fillStyle = 'rgba(255,255,255,'+a+')'; ctx.arc(s.x, s.y, 2.3, 0, Math.PI*2); ctx.fill(); ctx.globalAlpha = 1; if(s.life > s.maxLife || s.x>W+200) shootingStars.splice(i,1); }

  requestAnimationFrame(draw);
}
requestAnimationFrame(draw);

function drawMoon(x,y,r,t){
  // soft glow
  const g = ctx.createRadialGradient(x, y, 6, x, y, r*2.2);
  g.addColorStop(0, 'rgba(246,247,251,0.98)'); g.addColorStop(1,'rgba(52,70,100,0)');
  ctx.fillStyle = g; ctx.beginPath(); ctx.arc(x,y,r*1.05,0,Math.PI*2); ctx.fill();
  // moon circle
  ctx.fillStyle = 'rgba(245,246,250,0.98)'; ctx.beginPath(); ctx.arc(x,y,r*0.9,0,Math.PI*2); ctx.fill();
  // craters texture
  ctx.globalAlpha = 0.12;
  for(let i=0;i<10;i++){ const a = (i/10)*Math.PI*2 + (t*0.05); const rr = rand(r*0.12, r*0.42); const cx = x + Math.cos(a)*rr*0.4; const cy = y + Math.sin(a)*rr*0.35; ctx.beginPath(); ctx.arc(cx, cy, rand(3,8), 0, Math.PI*2); ctx.fillStyle='rgba(180,180,190,0.9)'; ctx.fill(); }
  ctx.globalAlpha = 1;
}

function drawMountain(m, t){
  // fill shape via polygon
  ctx.beginPath();
  ctx.moveTo(0, H);
  for(const p of m.points) ctx.lineTo(p.x, p.y + Math.sin((p.x*0.005)+(t*0.2*m.depth))*8);
  ctx.lineTo(W, H); ctx.closePath();
  // shade
  const c = m.color;
  ctx.fillStyle = c; ctx.fill();
  // subtle top highlight
  ctx.strokeStyle = 'rgba(255,255,255,'+(0.02 + m.depth*0.02)+')'; ctx.lineWidth = 1; ctx.stroke();
}

function drawForegroundCliff(t){
  const cliffY = Math.round(H*0.7);
  // layered rock shapes
  const grad = ctx.createLinearGradient(0, cliffY, 0, H);
  grad.addColorStop(0,'#25303f'); grad.addColorStop(1,'#3e2b40');
  ctx.fillStyle = grad; ctx.fillRect(0, cliffY, W, H - cliffY);

  // grass top
  const grassH = 34; const grassY = cliffY + 6;
  const grassGrad = ctx.createLinearGradient(0, grassY, 0, grassY+grassH);
  grassGrad.addColorStop(0,'#2b6a4a'); grassGrad.addColorStop(1,'#173b2a');
  ctx.fillStyle = grassGrad; ctx.fillRect(0, grassY, W, grassH);

  // grass blades detail (pixel-like clusters)
  ctx.globalAlpha = 0.9;
  for(let x=0; x<W; x+=6){ const h = rand(6, grassH-6); ctx.fillStyle = (Math.random()>0.5? '#2f7a53' : '#1f5e3f'); ctx.fillRect(x, grassY + grassH - h, 4, h); }
  ctx.globalAlpha = 1;

  // small flowers / color accents
  for(let i=0;i<40;i++){ const x = rand(40, W-40); const y = grassY + rand(4, grassH-8); if(Math.random()<0.12){ ctx.fillStyle = (Math.random()<0.5? '#ffd1e1' : '#ffdf99'); ctx.fillRect(x,y,2,2); } }
}

function drawBench(x,y,w,h,t){
  // bench shadow
  ctx.fillStyle = 'rgba(0,0,0,0.45)'; ctx.fillRect(x-16, y + h - 6, w + 32, 12);

  // legs (metal)
  ctx.fillStyle = '#22242b'; ctx.fillRect(x+14, y+12, 10, 34); ctx.fillRect(x+w-24, y+12, 10, 34);
  // supports
  ctx.fillRect(x+14, y+8, w-28, 6);

  // wooden seat planks
  const palette = ['#6b3f2a','#7b4b31','#8b5b42'];
  for(let i=0;i<3;i++){
    const py = y + i*12;
    ctx.fillStyle = palette[i%palette.length]; ctx.fillRect(x, py, w, 12);
    // grain highlight
    ctx.globalAlpha = 0.08 + i*0.02; ctx.fillStyle = '#ffffff'; ctx.fillRect(x+8, py+2, w-16, 1);
    ctx.globalAlpha = 1;
  }

  // backrest slightly tilted right
  ctx.save(); ctx.translate(x + w*0.6, y - 20); ctx.rotate(0.07);
  ctx.fillStyle = palette[1]; ctx.fillRect(-w*0.2, -6, w*0.6, 16);
  ctx.restore();

  // cushion detail
  ctx.fillStyle = 'rgba(255,255,255,0.04)'; ctx.fillRect(x+18, y+10, 36, 8);
}

// Start with a visible shooting star to feel alive
setTimeout(spawnShootingStar, 900);

// Start audio on first user interaction (some browsers require gesture)
function ensureAudioOnUserGesture(){
  const init = ()=>{ if(!audioCtx){ setupAudio(); audioCtx.resume(); } window.removeEventListener('pointerdown', init); };
  window.addEventListener('pointerdown', init);
}
ensureAudioOnUserGesture();

// Nice to have: allow keyboard M to toggle
window.addEventListener('keydown', (e)=>{ if(e.key.toLowerCase() === 'm'){ muteBtn.click(); } });

// Friendly note: keep pixel look even on high DPI by scaling drawing operations
// We'll draw with native size but the CSS sets image-rendering:pixelated for it to keep chunky pixels.

</script>
</body>
</html>
